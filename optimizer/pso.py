from .problem import Problem

import math
import numpy as np
import random

from concurrent.futures import ProcessPoolExecutor, as_completed
from tqdm import tqdm


# ---------------------------------------------------------
# Particle Swarm Optimizer implementation - optimizer class
# ---------------------------------------------------------

class PsoOptimizer:

    def __init__(self, model_filepath: str, tmp_filepath: str, no_workers: int = 4):
        self.v_max = 0.1                 # Maximum velocity value
        self.personal_c = 2.0            # Personal coefficient factor
        self.social_c = 2.0              # Social coefficient factor

        # Other optimization parameters
        self.model_filepath = model_filepath
        self.tmp_filepath = tmp_filepath
        self.no_workers = no_workers

        # Optimization history
        # - Saved optimization progress
        self.best_fitness_history = []
    

    def optimize(self, problem: Problem, no_particles: int = 10, steps: int = 10,
                 verbose: bool = False, logging_freq: int = 10) -> tuple[np.ndarray, float]:
        ''' Performs PSO to find a solution that minimizes problem.evaluate() function values 
        
            Returns a pair of (best_solution, best_solution_eval).
            - logging_freq: number of iterations between logs
        '''
        
        # Step 0 - clear history tables
        self.best_fitness_history.clear()

        # Step 1 - Generate initial population with respect dimensionality
        # - W for particle positions
        # - v for particle velocities
        W = np.random.uniform(problem.lb, problem.ub, (no_particles, problem.dim))
        v = np.zeros_like(W)      # zeros_like() automatically copies dimensionality of an array

        with ProcessPoolExecutor(max_workers=self.no_workers) as executor:
            # Step 2 - Evaluate initial population fitness
            # - Iterates over population ranks (position of a single shark) and creates 1D fitness vector
            # - Parallel execution
            from .worker import evaluate_with_local_worker

            fitness = np.empty(no_particles)

            future_to_idx = {
                executor.submit(
                    evaluate_with_local_worker,
                        W[i, :],
                        self.model_filepath,
                        self.tmp_filepath,
                        problem.time_hrs,
                        problem.measured_df,
                        problem.dim,
                        problem.lb,
                        problem.ub
                ): i for i in range(no_particles)
            }

            for future in as_completed(future_to_idx):
                i = future_to_idx[future]
                try:
                    fitness[i] = future.result()
                except Exception as exc:
                    print(f'Exception generated by shark {i}: {exc}')
                    fitness[i] = np.inf

            fitness_min = np.min(fitness)
            W_best = W.copy()                   # 2D matrix
            W_gbest = W[np.argmin(fitness)]     # 1D vector

            # Initialize inertia weight
            inertia_weight = 0.5 + (np.random.rand()/2)

            for k in tqdm(range(1, steps + 1)):
                # 1) Generate random matrices r1 and r2 of shape (no_particles, dim)
                r1 = np.random.rand(no_particles, problem.dim)
                r2 = np.random.rand(no_particles, problem.dim)

                # 2) Compute personal and social components for all particles
                personal = self.personal_c * r1 * (W_best - W)         # (no_particles, dim)
                social   = self.social_c * r2 * (W_gbest - W)           # broadcast gbest: (dim,) -> (no_particles, dim)

                # 3) Update velocities
                v = inertia_weight * v + personal + social

                # 4) Clip velocities to the allowed range [-v_max, v_max]
                v = np.clip(v, -self.v_max, self.v_max)

                # 5) Update particle positions
                W = W + v

                # 6) Return the particles to the original solution space
                W = np.clip(W, problem.lb, problem.ub)

                # Step 7 - evaluate and update best positions
                # - Multithreading enabled
                future_to_particle = {
                    executor.submit(
                        evaluate_with_local_worker,
                        W[i, :],
                        self.model_filepath,
                        self.tmp_filepath,
                        problem.time_hrs,
                        problem.measured_df,
                        problem.dim,
                        problem.lb,
                        problem.ub
                    ): i for i in range(no_particles)
                }

                for future in as_completed(future_to_particle):
                    i = future_to_particle[future]
                    try:
                        fit = future.result()
                        if fit < fitness[i]:
                            W_best[i, :] = W[i, :]
                            fitness[i] = fit
                        if fitness[i] < fitness_min:
                            fitness_min = fitness[i]
                            W_gbest = W_best[i].copy()
                    except Exception as exc:
                        print(f'Exception generated by particle {i}: {exc}')
                
                # Save optimization progress to history tables
                self.best_fitness_history.append(fitness_min)
                
                # Verbose logging
                if verbose and k % logging_freq == 0:
                    progress = k / steps
                    print(f"\nProgress: {int(progress*100)}% | Best fitness: {fitness_min:.8f}")
        
        return W_gbest, fitness_min
